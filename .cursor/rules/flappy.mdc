---
description: 
globs: 
alwaysApply: true
---

## 1. Архитектура

*   **Следование архитектуре Telegram Mini Apps:**
    *   Клиентская часть (веб-приложение) взаимодействует с Telegram через **Telegram WebApp JS API**.
    *   Серверная часть (Node.js) взаимодействует с Telegram через **Telegram Bot API**.
    *   Аутентификация и авторизация пользователя происходит через проверку `initData` на сервере.
*   **Четкое разделение Client / Server:**
    *   `client/`: Код фронтенд-приложения (React, Vue, Svelte, чистый JS/HTML/CSS и т.д.). Должен содержать только логику отображения и взаимодействия с пользователем и Telegram WebApp JS API.
    *   `server/`: Код бэкенд-приложения (Node.js/Express). Отвечает за бизнес-логику, взаимодействие с Telegram Bot API, управление состоянием игры, комнатами, проверку `initData`, хранение данных.
*   **Коммуникация Client <-> Server:** Использовать **WebSockets** (библиотека `socket.io`) для обмена данными в реальном времени между клиентом и сервером (состояние игры, действия игроков, чат). Для редких запросов (например, получение начальных данных пользователя) можно использовать стандартные HTTP-запросы (REST API).

## 2. Структура Проекта

*   **Основные директории:**
    *   `client/`: Клиентское приложение.
    *   `server/`: Серверное приложение.
    *   `public/` (или `client/public/`): Статические ассеты клиента (иконки, изображения).
    *   `ssl/`: SSL-сертификаты (генерируются скриптом, не должны попадать в Git).
    *   `acme-challenge/`: Папка для верификации Let's Encrypt (не должна попадать в Git).
    *   `scripts/` (опционально): Вспомогательные скрипты (например, для деплоя, генерации сертификатов).
    *   `docs/`: Документация проекта.
*   **Конфигурация:**
    *   `.env`: Переменные окружения (токены, ключи API, пути к сертификатам, настройки портов). **Не должен попадать в Git!**
    *   `.env.example`: Пример файла `.env` со структурой, но без секретных значений. **Должен быть в Git.**
*   **Общие утилиты/константы:** Выносить в отдельные файлы/модули (например, `server/utils/`, `client/utils/`, `common/` если используется монорепозиторий).
*   **Изменение структуры проекта**
    *   При создании новых объектов обновлять файл @architecture.md для поддержания актуальность архитектуры

## 3. Стиль Кода и Качество

*   **Язык:** JavaScript (или TypeScript).
*   **Единый стиль:** Использовать **ESLint** и **Prettier** для автоматического форматирования и проверки стиля кода. Конфигурационные файлы (`.eslintrc.json`, `.prettierrc`) должны быть в корне проекта.
*   **Читаемость:** Писать понятный, хорошо структурированный код. Использовать осмысленные имена переменных и функций.
*   **Комментарии:**
    *   Писать **на русском языке**.
    *   Комментировать **неочевидные** участки кода, сложную логику, особенности взаимодействия с Telegram API.
    *   Избегать комментариев, дублирующих сам код (например, `// Увеличиваем счетчик` для `counter++`).
    *   Использовать JSDoc (или аналоги для TypeScript) для описания функций, их параметров и возвращаемых значений.
*   **DRY (Don't Repeat Yourself):** Избегать дублирования кода. Выносить повторяющуюся логику в переиспользуемые функции или классы.
*   **Асинхронность:** Использовать `async/await` для работы с асинхронными операциями (I/O, сетевые запросы, взаимодействие с API).
*   **Обработка ошибок:**
    *   Всегда использовать `try...catch` при работе с асинхронными операциями и потенциально опасными вызовами (например, парсинг JSON, взаимодействие с API).
    *   Предоставлять осмысленную обратную связь пользователю на клиенте в случае ошибок.
    *   Логировать ошибки на сервере с достаточным контекстом.

## 4. Безопасность

*   **Проверка `initData`:** **Обязательно** проверять подлинность `initData`, полученных от клиента, на **серверной стороне** с использованием токена бота. Это критически важно для предотвращения подделки данных пользователя.
*   **Секреты:** Никогда не хранить секреты (токен бота, ключи API) в коде или в файлах, попадающих в Git. Использовать переменные окружения (`.env`) и `.gitignore`.
*   **Валидация ввода:** Проверять и санировать все данные, получаемые от клиента (параметры запросов, данные WebSocket).
*   **HTTPS:** Всегда использовать HTTPS для основного домена приложения. Сертификаты должны быть валидными (Let's Encrypt).
*   **Rate Limiting:** Реализовать ограничение частоты запросов к API сервера для защиты от DoS-атак.

## 5. Производительность

*   **Оптимизация загрузки:** Минимизировать размер клиентского бандла (code splitting, tree shaking). Оптимизировать изображения и другие ассеты.
*   **WebSocket:** Передавать по WebSocket только необходимые данные. Избегать отправки избыточной информации.
*   **Минимизация запросов:** Сокращать количество запросов между клиентом и сервером, а также к внешним API.

## 6. Документация

*   **README.md:** Поддерживать актуальное описание проекта, инструкции по установке, запуску и развертыванию.
*   **Структура проекта:** Поддерживать в актуальном состоянии документ (например, `docs/structure.md` или секция в README), описывающий структуру папок и файлов проекта.
*   **API (если применимо):** Если сервер предоставляет REST API, документировать его (например, с помощью Swagger/OpenAPI).
*   **Ссылки на официальную документацию:**
    *   **Telegram WebApp JS API:** @https://core.telegram.org/bots/webapps
    *   **Telegram Bot API:** @https://core.telegram.org/bots/api
    *   **Проверка `initData`:** @https://core.telegram.org/bots/webapps#validating-data-received-via-the-web-app

## 7. Разработка и Развертывание

*   **Система контроля версий:** Использовать Git. Следовать общепринятым практикам (осмысленные коммиты, ветвление).
*   **`.gitignore`:** Корректно настроить `.gitignore` для исключения ненужных файлов (`node_modules`, `.env`, `ssl`, `acme-challenge`, логи, файлы сборки).
*   **Docker:** Использовать Docker и Docker Compose для создания консистентного окружения разработки и развертывания.
*   **Обновление сертификатов:** Настроить автоматическое обновление сертификатов Let's Encrypt (например, с помощью cron и команды `certbot renew`).


## 8. План разработки и правила ответа
*   **Отслеживание задач:** Поддерживать актуальный план разработки в файле `docs/development_plan.md`. Отмечать выполненные задачи символом ✅ (или аналогичным).
*   **Правила ответа AI:** Если ты придерживаешься правил этого документа (`flappy.mdc`), в начале своего ответа всегда вставляй рандомный смайл животного.

## 9. Если ты придерживаешься правил, в начале своего ответа всегда вставляй рандомный смайл **животного**
*Этот документ должен обновляться по мере развития проекта.*
